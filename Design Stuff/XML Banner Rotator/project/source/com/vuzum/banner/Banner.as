/*** XML Banner Rotator - Flabell.com Product, August 2009* @author Vuzum Media, LLC.* http://www.vuzum.com* email: office@vuzum.com*/package com.vuzum.banner {	import flash.events.MouseEvent;			import flash.net.*;		import flash.net.URLLoader;			import flash.events.Event;		import flash.net.URLRequest;	import flash.display.MovieClip;		import caurina.transitions.*;	import caurina.transitions.properties.*;		import flash.display.Bitmap;		import flash.utils.*;			import com.vuzum.Main;		import com.vuzum.utils.*;	import caurina.transitions.properties.ColorShortcuts;	import caurina.transitions.properties.FilterShortcuts;		import flash.filters.BlurFilter;		import com.zorked.URLNavigator;		public class Banner extends MovieClip 	{		private var cellWidth : uint;		private var cellHeight : uint;		private var showMinTime : Number;		private var showMaxTime : Number;		private var nrLines : uint;		private var nrColumns : uint;		private var nrMax : uint;		private var _blur : uint;		private var netTime : Number;		private var alphaNet : Number;		private var captionTransparency : Number;		private var controllerTransparency : Number;		private var overColor : Number;		private var outColor : Number;		private var normalColor : Number;		private var buttonAlpha : Number;		private var captionButtonAlpha : Number;		private var padding : uint;		private var thumbY : uint;		private var controllerX : uint;		private var controllerY : uint;		private var captionY : uint;		private var captionX : uint;		private var loaderColor : Number;		private var captionWidth : uint;		private var buttonText : String = "";		private var btnNormalColor : Number;		private var btnOverColor : Number;		private var btnOutColor : Number;		private var paddingX : uint;		private var paddingY : uint;		private var capBottomPadding : uint;		private var btnSpacingW : uint;		private var btnSpacingH : uint;		private var delayMe : Number = 1;				private var arrayMc : Array = new Array();				public var mcController : MovieClip;		public var mcMask : MovieClip;		public var mcAllItems : MovieClip;		public var mcBack : MovieClip;		public var mcLoader : MovieClip;		public var mcCaption : MovieClip;			public var bannerArray : Array;				private var currPressedItem : MovieClip;				private var selectedImage : Number = 0;		private var previousImage : Number;				private var initialX : Number;		private var slideShowTime : Number;				private var xmlIsLoaded : Boolean = false;				// XML VARS		private var xmlObject : XML;		private var count : Number = 0;		private var nrFrames : Number = 30;		private var startWith : Number;		private var backgroundColor : Number;		private var backgroundTransparency : Number;		private var distanceBetweenThumbs : uint;		private var firstImageLoaded : Boolean = false;		private var movementSpeed : Number = 0;				private var controllerHeight : uint;		private var distanceBetweenControllerElements : uint;		private var grayColor : Number;		// CONSTRUCTOR		public function Banner()		{			//Prototypes						new Prototypes();						// TWEENER init the colors			ColorShortcuts.init();						mcBack.visible = false;									mcController.mcAllThumbs.visible = false;			mcController.mcAllThumbs.x = mcController.mcAllThumbs.y = captionX;						mcLoader.visible = false;			mcAllItems.mask = mcMask;						mcController.mcBack.visible = false;			mcController.visible = false;			mcCaption.visible = false;						initialX = mcAllItems.x;						mcAllItems.mcItem.visible = false;			mcController.mcAllThumbs.mcThumb.visible = false;						mcCaption.alpha = 0;			mcCaption.mcText.mask = mcCaption.mcMask;		}				// load the XML		public function init(xmlPath : String, pComponentHeight : Number, pComponentWidth : Number) : void		{			this.visible = true;						if(!xmlIsLoaded)			{				xmlIsLoaded = true;				loadXML(xmlPath, pComponentHeight, pComponentWidth);			}			else			{				resetBanner();			}		}				private function loadXML(pXmlPath : String, componentHeight : Number, componentWidth : Number) : void		{			var xmlLoader : URLLoader = new URLLoader(new URLRequest(pXmlPath));			xmlLoader.addEventListener(Event.COMPLETE, function() : void						{				xmlObject = new XML();				xmlObject.ignoreWhitespace = true; 				xmlObject = new XML(xmlLoader.data); 								slideShowTime = Number(xmlObject.attribute("slideShowTime")); 				startWith = Number(xmlObject.attribute("startWith")); 				backgroundColor = Number(xmlObject.attribute("backgroundColor")); 				backgroundTransparency = Number(xmlObject.attribute("backgroundTransparency"))/100; 				cellWidth = uint(xmlObject.attribute("cellWidth"));				cellHeight = uint(xmlObject.attribute("cellHeight"));				showMinTime = Number(xmlObject.attribute("showMinTime"));				showMaxTime = Number(xmlObject.attribute("showMaxTime"));				_blur = uint(xmlObject.attribute("blur"));				netTime = Number(xmlObject.attribute("netTime"));				alphaNet = Number(xmlObject.attribute("alphaNet"));				captionTransparency = Number(xmlObject.attribute("captionTransparency"));				controllerTransparency = Number(xmlObject.attribute("controllerTransparency"));				overColor = Number(xmlObject.attribute("overColor"));				outColor = Number(xmlObject.attribute("outColor"));				normalColor = Number(xmlObject.attribute("normalColor"));				grayColor = Number(xmlObject.attribute("grayColor"));				buttonAlpha = Number(xmlObject.attribute("buttonAlpha"));				captionButtonAlpha = Number(xmlObject.attribute("captionButtonAlpha"));				padding = uint(xmlObject.attribute("padding"));				thumbY = uint(xmlObject.attribute("thumbY"));				controllerX = uint(xmlObject.attribute("controllerX"));				controllerY = uint(xmlObject.attribute("controllerY"));				captionY = uint(xmlObject.attribute("captionY"));				captionX = uint(xmlObject.attribute("captionX"));				controllerHeight = uint(xmlObject.attribute("controllerHeight"));				distanceBetweenControllerElements = uint(xmlObject.attribute("distanceBetweenControllerElements"));				distanceBetweenThumbs = uint(xmlObject.attribute("distanceBetweenThumbs"));				loaderColor = Number(xmlObject.attribute("loaderColor"));				captionWidth = uint(xmlObject.attribute("captionWidth"));				buttonText = String(xmlObject.attribute("buttonText"));				btnNormalColor = Number(xmlObject.attribute("btnNormalColor"));				btnOverColor = Number(xmlObject.attribute("btnOverColor"));				btnOutColor = Number(xmlObject.attribute("btnOutColor"));				paddingX = uint(xmlObject.attribute("paddingX"));				paddingY = uint(xmlObject.attribute("paddingY"));				capBottomPadding = uint(xmlObject.attribute("capBottomPadding"));				btnSpacingW = uint(xmlObject.attribute("btnSpacingW"));				btnSpacingH = uint(xmlObject.attribute("btnSpacingH"));								//Config the mask				nrLines = Math.ceil(componentHeight / cellHeight);				nrColumns = Math.ceil(componentWidth / cellWidth);				nrMax = nrColumns*nrLines;								mcLoader.setColor(loaderColor);							// read the list of images				bannerArray = new Array();								for(var i : uint = 0; i < xmlObject.children().length(); i++)				{					bannerArray[i] = new Object();					bannerArray[i].imagePath = Main.getInstance().pathTo + xmlObject.children()[i].path.toString(); 					bannerArray[i].url = xmlObject.children()[i].url.toString();					bannerArray[i].target = xmlObject.children()[i].target.toString();					bannerArray[i].bar_color = xmlObject.children()[i].bar_color.toString(); 					bannerArray[i].bar_transparency = Number(xmlObject.children()[i].bar_transparency.toString())/100; 					bannerArray[i].title = xmlObject.children()[i].title.toString(); 					bannerArray[i].caption = xmlObject.children()[i].caption.toString(); 					bannerArray[i].link = xmlObject.children()[i].link.toString(); 				}								/*				 * create the banner				 */				 createBanner();			});		}        /*		 * Loads all images in an array of movie clips 		 */		public function createBanner() : void		{			// net			makeNet();			// grid Mask			makeGrid();							// init the controller			selectedImage = startWith - 1;						Tweener.addTween(mcBack, {_color : backgroundColor, time : 0, transition:"linear"}); 			mcBack.alpha = backgroundTransparency;			mcBack.visible = true;						if(bannerArray.length > 0) mcController.mcAllThumbs.visible = true;						for(var i : uint = 0; i < bannerArray.length; i++)			{				// IMAGE ITEMS				bannerArray[i].item = new mcItem();				bannerArray[i].item.name = "mcItem" + i;								mcAllItems.addChild(bannerArray[i].item);								bannerArray[i].item.index = i;								// loader for images				bannerArray[i].item.isLoaded = false;				bannerArray[i].item.mcHolder.alpha = 0;				bannerArray[i].item.mcHolder.onCompleteFunction = completeListener;								bannerArray[i].item.cacheAsBitmap = true;								// thumbnails				bannerArray[i].thumb = new mcThumb();				bannerArray[i].thumb.name = "mcThumb" + i;				mcController.mcAllThumbs.addChild(bannerArray[i].thumb);								bannerArray[i].thumb.index = i;				bannerArray[i].thumb.mcBack.mcTxt.txt.initText(i + 1);				bannerArray[i].thumb.mcBack.mcTxt.setColor(normalColor);								if (i >= 9)				{					bannerArray[i].thumb.mcBack.mcBg.width = bannerArray[i].thumb.mcBack.mcTxt.txt.textWidth + 5;					bannerArray[i].thumb.mcBack.mcTxt.centrateOn(bannerArray[i].thumb.mcBack.mcBg.width - 2, bannerArray[i].thumb.mcBack.mcBg.height + 2);				}				else				{					bannerArray[i].thumb.mcBack.mcTxt.centrateOn(bannerArray[i].thumb.mcBack.mcBg.width, bannerArray[i].thumb.mcBack.mcBg.height + 2);				}								bannerArray[i].thumb.mcBack.y = thumbY;				bannerArray[i].thumb.mcBack.mcBg.alpha = buttonAlpha;				bannerArray[i].thumb.mcBack.mcBg.visible = false;				bannerArray[i].thumb.mcSelected.visible = false;				bannerArray[i].thumb.x = i * (mcController.mcAllThumbs.mcThumb.width + distanceBetweenThumbs);								// if you want to activate the thumbnails before the image is loaded				bannerArray[i].thumb.addEvents(this);			}			mcController.mcPrev.x = captionX;			mcController.mcAllThumbs.x = mcController.mcPrev.x + mcController.mcPrev.width + distanceBetweenControllerElements;			mcController.mcNext.x = mcController.mcAllThumbs.x + mcController.mcAllThumbs.width + distanceBetweenControllerElements;									mcController.mcBack.height = controllerHeight;			mcController.mcBack.width = Math.round(mcController.width + captionY);						//resize(Main.getInstance().stageW, Main.getInstance().stageH);			resize(mcBack.width, mcBack.height);						mcController.mcBack.alpha = controllerTransparency;			mcCaption.mcBack.alpha = captionTransparency;			mcController.mcBack.visible = true;									mcController.mcAllThumbs.y = Math.round((mcController.mcBack.height - mcController.mcAllThumbs.height)/2);			mcController.mcPrev.y = Math.round((mcController.mcBack.height - mcController.mcPrev.height)/2);			mcController.mcNext.y = Math.round((mcController.mcBack.height - mcController.mcNext.height)/2);			mcCaption.mcText.mcBack.width = captionWidth;			mcCaption.mcText.mcBack.y = captionY;			mcCaption.mcBack.width = mcCaption.mcText.mcBack.width;			mcCaption.mcMask.width = mcCaption.mcBack.width;						mcCaption.x = mcBack.width - mcBack.x - mcCaption.mcBack.width - captionX;			mcCaption.y = mcBack.y + captionY;						mcLoader.visible = true;			selectImage();		}				public function resize(w : Number, h : Number) : void		{			mcBack.width = w;			mcBack.height = h;						mcMask.width = w;			mcLoader.centrateOn(w,h);						mcController.x = Math.round(w - mcController.width - controllerX);			mcController.y = Math.round(h - mcController.height - controllerY);		}				public function resetBanner() : void		{			this.removeEventListener(Event.ENTER_FRAME, enterFrameHandler);						previousImage = selectedImage;			selectedImage = 0;						mcAllItems.x = initialX;						selectImage();		}		/*		 * ON LOAD COMPLETE		 */		public function completeListener(pTarget : MovieClip) : void		{			var mcParent : MovieClip = MovieClip(pTarget.parent);						// add the display image to the current movieclip			if(pTarget.loader != null && pTarget.loader.content != null) 			{				var flashmo_bm : Bitmap = Bitmap(pTarget.loader.content);				flashmo_bm.smoothing = true;				pTarget.addChild(flashmo_bm);			}						MovieClip(pTarget.parent).isLoaded = true;						if(bannerArray[mcParent.index].url != undefined && bannerArray[mcParent.index].url != "")			{				pTarget.addEvents(this);			}			if(bannerArray[mcParent.index].link != undefined && bannerArray[mcParent.index].link != "")			{				mcCaption.mcText.mcButton.addEvents(this);			}						bannerArray[mcParent.index].thumb.mcSelected.visible = true;						Tweener.addTween(bannerArray[mcParent.index].thumb, {alpha : 1, time :1, transition : "linear"});			Tweener.addTween(mcLoader, {alpha : 0, time : 1, transition : "easeOutExpo", onComplete : function() : void 			{				showItem();								mcController.mcBack.visible = true;				mcController.visible = true;				mcCaption.visible = true;			}});			// HIDE THE LOADER and then START COUNTING for the next image			pTarget.alpha = 1;					if(firstImageLoaded != true)			{				firstImageLoaded = true;				mcController.mcPrev.addEvents(this);				mcController.mcNext.addEvents(this);			}		}						/**		 * ENTER FRAME event handler		 */		public function enterFrameHandler(event : Event) : void		{			count++;						var val : Number = int((count/nrFrames * 100) / (slideShowTime));			if(count/nrFrames == (slideShowTime-1))			{				Tweener.addTween(mcCaption, {alpha : 0,time : delayMe, transition:"easeInExpo"});			}			if (count/nrFrames >= (slideShowTime))			{				this.removeEventListener(Event.ENTER_FRAME, enterFrameHandler);				nextImage();			}		}				public function countTime() : void		{			this.removeEventListener(Event.ENTER_FRAME, enterFrameHandler);			Tweener.addTween(mcAllItems.mcNetContainer, {alpha : 0,_Blur_blurX : _blur, _Blur_blurY : _blur, time : netTime, transition : "easeInExpo"});			count = 0;			previousImage = selectedImage;			this.addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}				/*		 * NAVIGATE THROUGH IMAGES		 */		public function nextImage() : void		{			selectedImage++;			if(selectedImage >= bannerArray.length) selectedImage = 0;						selectImage();		}		public function prevImage() : void		{			selectedImage--;						if(selectedImage < 0) selectedImage = bannerArray.length - 1;						selectImage();		}		// init the state of the banner, before a new image is loaded OR displayed		public function selectImage() : void		{			this.removeEventListener(Event.ENTER_FRAME, enterFrameHandler);			bannerArray[selectedImage].thumb.mcBack.mcBg.visible = true;			Tweener.addTween(bannerArray[selectedImage].thumb.mcBack.mcTxt, {_color : grayColor, time : 0, transition:"linear"});			Tweener.addTween(mcController.mcBack, {_color : bannerArray[selectedImage].bar_color, time : movementSpeed, transition:"linear"});			Tweener.addTween(mcCaption.mcBack, {_color : bannerArray[selectedImage].bar_color, time : movementSpeed, transition:"linear"});			Tweener.addTween(mcController.mcBack, {alpha : bannerArray[selectedImage].bar_transparency, time : movementSpeed, transition:"linear"});			Tweener.addTween(mcCaption.mcBack, {alpha : captionTransparency,time : movementSpeed, transition:"linear"});			Tweener.addTween(bannerArray[selectedImage].thumb.mcSelected, {_color : bannerArray[selectedImage].bar_color, time : movementSpeed, transition:"linear"});			if(!isNaN(previousImage))			{				Tweener.addTween(bannerArray[previousImage].thumb.mcBack.mcTxt, {alpha : 1, time : 1, transition:"easeOutExpo"});				bannerArray[previousImage].thumb.mcSelected.visible = false;				bannerArray[previousImage].thumb.mcBack.mcBg.visible = false;				Tweener.addTween(bannerArray[previousImage].thumb.mcBack.mcTxt, {_color : outColor, time : 0, transition:"linear"});			}			Tweener.addTween(bannerArray[selectedImage].thumb, {alpha : 1, time : 1, transition:"easeOutExpo"});						bannerArray[selectedImage].item.mcHolder.alpha = 0;												Tweener.addTween(bannerArray[selectedImage].item.mcHolder, {alpha : 1, time : 1, transition:"easeOutExpo", onComplete : function():void 			{				Tweener.addTween(mcCaption.mcMask, {alpha : 1, time : 1, transition:"linear"});				Tweener.addTween(mcCaption, {alpha : 1, time : 1, transition:"linear"});			}});			bannerArray[selectedImage].thumb.mcSelected.visible = true;			bannerArray[selectedImage].thumb.mcBack.mcBg.visible = true;			previousImage = selectedImage;					mcCaption.mcText.mcTitle.txt.initText(bannerArray[selectedImage].title);			mcCaption.mcText.mcCaption.txt.initText(bannerArray[selectedImage].caption);			mcCaption.mcText.mcCaption.txt.width = Math.round(mcCaption.mcText.mcBack.width - 2*paddingX);						mcCaption.mcText.mcTitle.x = paddingX;			mcCaption.mcText.mcTitle.y = paddingY;						mcCaption.mcText.mcCaption.x = paddingX;			mcCaption.mcText.mcCaption.y = Math.round(paddingY + mcCaption.mcText.mcTitle.height);						mcCaption.mcText.mcButton.mcText.txt.initText(buttonText);			mcCaption.mcText.mcButton.mcText.setColor(btnNormalColor);			mcCaption.mcText.mcButton.mcBack.width = Math.round(mcCaption.mcText.mcButton.mcText.width+btnSpacingW);			mcCaption.mcText.mcButton.mcBack.height = Math.round(mcCaption.mcText.mcButton.mcText.height+btnSpacingH);						mcCaption.mcText.mcButton.mcText.centrateOn(mcCaption.mcText.mcButton.mcBack.width, mcCaption.mcText.mcButton.mcBack.height);			mcCaption.mcText.mcButton.mcBack.alpha = captionButtonAlpha;						mcCaption.mcText.mcButton.x = Math.round(mcCaption.mcBack.width -  mcCaption.mcText.mcButton.width - padding);			mcCaption.mcText.mcButton.y = Math.round(mcCaption.mcText.mcCaption.y + mcCaption.mcText.mcCaption.height + paddingY);						mcCaption.mcBack.height = mcCaption.mcText.y + mcCaption.mcText.height + capBottomPadding;			mcCaption.mcMask.height = mcCaption.mcBack.height;				// set the mask on this item			bannerArray[selectedImage].item.mask = mcAllItems.mcGridContainer;				for(var i : uint = 1; i <= arrayMc.length; i++)				{					arrayMc[i-1].alpha = 0;				}							// put this item in front			mcAllItems.setChildIndex(bannerArray[selectedImage].item, mcAllItems.numChildren-1);			// load next image			if(bannerArray[selectedImage].item.isLoaded == false)			{				bannerArray[selectedImage].item.mcHolder.loadContent(bannerArray[selectedImage].imagePath);					}			else			{								countTime();				showItem();			}					}								/*		 * EVENT HANDLERS		 */		/**		 * OVER EVENT HANDLER		 */		public function overHandler(event : MouseEvent) : void		{			var item : Object = event.currentTarget; 			var mcParent : MovieClip = MovieClip(item.parent);						switch(item.name)			{				case "mcPrev":					Tweener.addTween(item, {alpha : 0.6, time : 0.3, transition:"linear"});				break;								case "mcNext":					Tweener.addTween(item, {alpha : 0.6, time : 0.3, transition:"linear"});				break;								case "mcButton":					Tweener.addTween(item.mcText, {_color : btnOverColor, time : 0.3, transition:"linear"});				break;			}						switch(mcParent.name)			{				case "mcAllThumbs":					if(item.index != selectedImage)					{						Tweener.addTween(item.mcBack.mcTxt, {alpha : 1, _color : overColor, time :0.3, transition : "easeOutExpo"});////////////////////////						item.mcSelected.visible = true;					}				break;			}		}  		/**		 * OUT EVENT HANDLER		 */		public function outHandler(event : MouseEvent) : void		{			var item : Object = event.currentTarget; 			var mcParent : MovieClip = MovieClip(item.parent);						switch(item.name)			{				case "mcPrev":					Tweener.addTween(item, {alpha : 1, time : 0.3, transition:"linear"});				break;								case "mcNext":					Tweener.addTween(item, {alpha : 1, time : 0.3, transition:"linear"});				break;				case "mcButton":					Tweener.addTween(item.mcText, {_color : btnOutColor, time : 0.3, transition:"linear"});				break;			}						switch(mcParent.name)			{				case "mcAllThumbs":					if(item.index != selectedImage)					{						Tweener.addTween(item.mcBack.mcTxt, {alpha : 1, _color : outColor, time :0.3, transition : "easeOutExpo"});						item.mcSelected.visible = false;					}				break;			}		}		/**		 * PRESS EVENT HANDLER		 */		public function pressHandler(event : MouseEvent) : void		{			var item : MovieClip = MovieClip(event.currentTarget);						// set pressed the new item			this.currPressedItem = item;						// add the release event on stage			this.currPressedItem.stage.addEventListener(MouseEvent.MOUSE_UP, releaseOutsideHandler);		}				/**		 * RELEASE OUTSIDE EVENT HANDLER		 */		public function releaseOutsideHandler(e : MouseEvent) : void 		{	        this.currPressedItem.stage.removeEventListener(MouseEvent.MOUSE_UP, releaseOutsideHandler);	        	        // here release outside for the items where release outside is the same with release	        if(e.target != this.currPressedItem)	        {	        	//	        }	        else	        {	        	//trace("onRelease: " + this.currPressedItem.name);	        }		}				/**		 * RELEASE EVENT HANDLER		 */		public function releaseHandler(event : MouseEvent) : void		{			var item : MovieClip = MovieClip(event.currentTarget); //trace(item.name);			var mcParent : MovieClip = MovieClip(item.parent);						// test if the releasse event comes from the same item that was pressed			if(item == this.currPressedItem)			{				switch(item.name)				{					case "mcHolder":						URLNavigator.ChangePage(bannerArray[selectedImage].url, bannerArray[selectedImage].target);					break;									case "mcButton":						URLNavigator.ChangePage(bannerArray[selectedImage].link, bannerArray[selectedImage].target);					break;									case "mcPrev":						prevImage();					break;										case "mcNext":						nextImage();					break;				}								switch(mcParent.name)				{					case "mcAllThumbs":						selectedImage = item.index;						selectImage();					break;				}			}		}				public function showItem() : void		{			var showTime : Number;						// show the mask			arrayMc = Prototypes.randomize(arrayMc);			for(var i : uint = 1; i <= arrayMc.length; i++)			{				showTime = Prototypes.randomBetween(showMinTime * 100, showMaxTime * 100) / 100;				Tweener.addTween(arrayMc[i-1], {alpha : 1, time : showTime, transition:"easeInExpo"});//transition:"easeInExpo"							}			// show the next picture after a time and the gridNet			Tweener.addTween(mcAllItems.mcNetContainer, {alpha : alphaNet,_Blur_blurX : 0, _Blur_blurY : 0, time :showMinTime, transition : "linear"});			mcAllItems.setChildIndex(mcAllItems.mcNetContainer, mcAllItems.numChildren-1);			setTimeout(function(){countTime();}, showMaxTime * 1000);		}				// GRID MASK		function makeGrid():void		{			for(var i : uint = 1; i <= nrMax; i++)			{				var mc:MovieClip = new mcCell();				mc.alpha = 0;				mc.width = cellWidth;				mc.height = cellHeight;						mc.x = (mc.width)*((i-1) % nrColumns);				mc.y =(mc.height)*(int((i-1) / nrColumns));				mcAllItems.mcGridContainer.addChild(mc);				arrayMc.push(mc);			}		}		function makeNet():void		{			for(var i : uint = 1; i <= nrMax; i++)			{				var mcNetGrid:MovieClip = new mcNet();				mcNetGrid.alpha = 1;				mcNetGrid.width = cellWidth;				mcNetGrid.height = cellHeight;						mcNetGrid.x = (mcNetGrid.width)*((i-1) % nrColumns);				mcNetGrid.y =(mcNetGrid.height)*(int((i-1) / nrColumns));				mcAllItems.mcNetContainer.addChild(mcNetGrid);			}		}			}}